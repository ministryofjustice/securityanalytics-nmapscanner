service: ${self:custom.appName}-${self:custom.pluginName}

externalGateway: &externalGateway
  restApiId: ${ssm:/${self:custom.appName}/${self:custom.ssmSourceStage}/api/public/id, ''}
  restApiRootResourceId: ${ssm:/${self:custom.appName}/${self:custom.deployStage}/api/public/root, ''}
  authorizer:
    type: COGNITO_USER_POOLS
    authorizerId: ${ssm:/${self:custom.appName}/${self:custom.ssmSourceStage}/api/public/authorizer, ''}

custom:
  appName: sec-an
  pluginName: nmap
  apiGatewayConfigOptions:
    dev: *externalGateway
    prod: *externalGateway
    other:
      restApiId: ""
      restApiRootResourceId: ""
      authorizer: ""
  # The build will provide SSM_SOURCE_STAGE, but local devs will get their username used
  ssmSourceStage: ${'${env:SSM_SOURCE_STAGE, env:USERNAME}'}
  deployStage: ${opt:stage, '${env:USERNAME}'}
  # If a defined integration exists in apiGatewayConfigOptions e.g. dev or prod
  # then serverless will take that value, if it is undefined it falls back to 'other'
  # which provides no api gateway details and serverless will create a new one for us
  apiGatewayConfig:
    ${self:custom.apiGatewayConfigOptions.${self:custom.deployStage}, self:custom.apiGatewayConfigOptions.other}
  output:
    file: .generated/stack.json
  exportEndpoints:
    path: .generated/endpoints.json
  pythonRequirements:
    cacheLocation: ${env:PWD}/.cache
    useDownloadCache: true
    useStaticCache: true
    dockerizePip: non-linux
    # setting this to true breaks the zip
    slim: false
    # Dont use zip, it makes things bigger because the no deploy filtering seems to be ignored
    zip: false
    # addDefaultNoDeploys: true
    noDeploy:
      # provided by our layer
      - utils
      # the rest by lambda
      - boto3
      - botocore
      - docutils
      - jmespath
      - python-dateutil
      - s3transfer
      - six
      - pip
      - setuptools

provider:
  name: aws
  runtime: python3.7
  region: ${opt:region, 'eu-west-2'}
  stage: ${self:custom.deployStage} # so when developing we keep things independent, can be overridden
  endpointType: REGIONAL # TODO
  # Here if we are on dev (or later qa or prod), then we hook up to the shared gateway
  # other wise we are probably just running integration tests and need to create our own gateway
  apiGateway:
    restApiId: ${self:custom.apiGatewayConfig.restApiId}
    restApiRootResourceId: ${self:custom.apiGatewayConfig.restApiRootResourceId}
# TODO additional efforts are needed to get lambdas to run inside the vpc
#  vpc:
#    securityGroupIds:
#      - TODO
#    subnetIds: ${ssm:/${self:custom.appName}/${self:custom.deployStage}/vpc/subnets/instance}
  iamRoleStatements:
    -  Effect: "Allow"
       Action:
         - "s3:GetBucketNotification"
         - "s3:PutBucketNotification"
       Resource:
         Fn::Join:
           - ""
           - - ${ssm:/${self:custom.appName}/${self:custom.deployStage}/tasks/${self:custom.pluginName}/s3/results/arn}

plugins:
  - serverless-stack-output
  - serverless-python-requirements
  - serverless-plugin-existing-s3
  # used for integration testing
  - serverless-plugin-export-endpoints
  # used for testing and local development
  - serverless-offline

package:
  individually: false
  # This negative include is important for performance
  # https://github.com/serverless/serverless/pull/5825
  include:
    - "!./**"
    - "./sample_lambda/**"
    - "./task_queue_consumer/**"
    - "./results_parser/**"
  exclude:
    - "**"

functions:
  sample: ${file(sample_lambda/sample.yml):function}
  taskQueueConsumer: ${file(task_queue_consumer/task_queue_consumer.yml):function}
  resultsParser: ${file(results_parser/results_parser.yml):function}

resources:
  Resources:
    sampleRole: ${file(sample_lambda/sample.yml):role}

